### 1、项目中是怎么使用的

**方式一：**

业务方维护分表规则，自己在代码中通过hash规则计算出物理表的表名，发往数据库服务的sql已经是计算好的表名，一般需要借助框架来实现，比如当当开源的ShardingSphere；

**方式二：**

使用DB-Proxy解析hint，将逻辑表替换为物理表，业务方在sql语句前面拼上sqlhint即可。

如：有一张订单表，拆分成100份，hash规则为将订单ID对100取模，那么代码中sql语句为：

```
/*{"pid":"20160721"}*/select order_id,create_time from order_info where order_id=20160721 limit 1;
```

sql语句发到db-proxy后会被解析成：

```
/*{"pid":"20160721"}*/select order_id,create_time from order_info_21 where order_id=20160721 limit 1;
```

然后将解析后的sql语句发往后端的MySQL执行；

**方式三：**

通过DB-Proxy的透明分表功能，业务方不需要做任何变化，DBA会配置好分表规则，使用时只需要注意一些使用细节，不要违反db-proxy透明分表的规范即可，比如：

- 在where条件中带上分表的key字段，不然会对所有表进行查询，然后将结果聚合，性能会很低
- select时指定具体的列名，比如线上在加列时，如果没有指定列表，proxy在合并数据的时候可能会由于列不相等而合并失败
- 不支持分布式事务，同一个事务不能包含多个分片
- 不支持子查询/join等复杂查询

### 2、为什么要分库分表

关键字：提升性能、增加可用性

- 从性能上看：

- - 如果数据库的查询QPS过高，就要考虑拆库，通过分库来分担单个数据库的连接压力；
  - 如果单表数据量过大，通过索引等优化后还是可能存在性能问题，这个时候需要考虑通过分表来解决单表的存取性能问题；

- 从可用性上看：

- - 单个数据库如果发送意外会丢失所有数据，通过分库后可以减少损失

### 3、如何分库分表

| 切分方案     | 解决的问题                                |
| ------------ | ----------------------------------------- |
| 只分库不分表 | 数据读/写QPS过高，数据库连接数不足        |
| 只分表不分库 | 单表数据量过大，存储性能遇到瓶颈          |
| 既分库又分表 | 连接数不足 + 数据量过大引起的存储性能瓶颈 |

- **确定要分多少张表：**提前预估每天产生的数据量，以及系统大致使用的年限，算出多少张表比较合适

- **切分方式：**

- - 水平切分：每张表里面的字段相同，数据基于某个规则分散到不同的表里面
  - 垂直切分：将不同的字段拆分到不同的表里面去，一般会按照不同的业务划分到不同的表中或库中

- **分库后带来的问题：**

- - 事务：分库后单机事务就失效了，需要使用分布式事务，复杂性和难度加大
  - 连表join：分库之后无法进行join，需要在代码中自己做关联

- **分表后带来的问题：**

- - 排序、count、分页问题：只能通过业务代码或者中间件将多个表的数据聚合后再返回，性能影响大

  - 路由问题

  - - **Hash路由：**

    - - 将分表列对分表数进行取模（ ID % 分表数量 ）
      - 将分表列hash之后对分表数取模（ hash(ID) % 分表数量 ）
      - 将分表列md5后取前N位，md5后是16进制的，这样分表数必须是16的N次方
      - 缺点：要增加子表时比较麻烦，需要对数据整体进行迁移
      - 优点：数据分布均匀，实现简单

    - 范围路由：

    - - 一般按照时间或者地区划分
      - 缺点：数据分布可能不均匀，支持的场景有限
      - 优点：容易扩展，几乎可以无限增加分表数

    - 路由表（索引表）：

    - - 建一个单独的表来存储路由信息，里面就两个字段，一个是分表列，一个是对应的表名，所以这张表能存储的数据会比较多，但是也是会有上限的，需要对路由表也进行分表
      - 缺点：需要多查一遍，一般会做缓存
      - 优点：灵活，数据迁移后只需改一下路由表

    - **一致性Hash：**

    - - 一致性Hash一般有2^23 - 1个节点
      - 缺点：实现略复制
      - 优点：分布更均匀，扩容容易

  - 全局主键问题

  - - 设置步长的自增，比如有3张表，步长设置为3，三张表初始值分别设置为1，2，3，那么第一张表ID是1，4，7；第二张表是2，5，8；第三张表是3，6，9；
    - UUID，不连续的主键会造成页分裂，性能比较差
    - 分布式ID，如twitter开源的sonwflake雪花算法
    - 用一张单独的表自增获取主键ID

  - 后期数据扩容问题

  - - 如果使用hash算法来分表，做扩容时需要对所有数据进行迁移，如果使用一致性Hash算法只需要迁移1/N份数据
    - 停服迁移：在晚上访问量小的时候对服务进行停服，防止新数据写入，然后将数据迁移到新的库中
    - 不停服迁移：同样在晚上操作，先将某个时间点的数据迁移到新库中，然后将写入切换到新库中，然后关掉老库写入，然后把增量数据写入新库

  - 分库后事务问题

  - - **使用分布式事务**

    - - 优点：由应用服务器/数据库去管理事务，实现简单
      - 缺点：性能代价高，尤其涉及到分库数量较多时尤为明显，而且还依赖一些特定的应用服务器/数据库提供的分布式事务实现方案

    - **由应用程序+数据库共同控制**

    - - 原理：大事化小，将多个大事务拆分成可由单个分库处理的小事务，由应用程序去控制这些小事务
      - 优点：性能良好，少了一个分布式事务协调处理层
      - 缺点：需要从应用程序自身上做事务控制的灵活设计。从业务应用上做处理，应用改造成本高

- **如何支持多个字段查询：**

- - 冗余数据：按另外一个要查询的字段冗余一份数据，比如按照商家ID再进行一次分表，数据冗余一般通过异步进行，不影响正常流程
  - 将数据同步到ES

### 4、什么是分区表

创建表的时候，使用了数据分区相关的语法，存储数据的时候，存储引擎会根据分区规则将不同的数据存入不同的分区文件。

缺点：

- MySQL 在第一次打开分区表的时候，需要访问所有的分区——打开的表较多，性能糟糕也可能报打开的表超过设置的问题。
- 在 server 层，认为这是同一张表，因此所有分区共用同一个 MDL 锁——锁粒度大，影响并发度，站在Server看也是合理的，不过站在存储引擎的角度看就不合理了。
- 在引擎层，认为这是不同的表，因此 MDL 锁之后的执行过程，会根据分区表规则，只访问必要的分区——被访问到的分区。

优点：

- 分区表的一个显而易见的优势是对业务透明，相对于用户分表来说，使用分区表的业务代码更简洁。还有，分区表可以很方便的清理历史数据。

什么时候使用：

- 单表过大时，使用时注意一下两点

- - 分区并不是越细越好。实际上，单表或者单分区的数据一千万行，只要没有特别大的索引，对于现在的硬件能力来说都已经是小表了。
  - 分区也不要提前预留太多，在使用之前预先创建即可。比如，如果是按月分区，每年年底时再把下一年度的 12 个新分区创建上即可。对于没有数据的历史分区，要及时的 drop 掉。

使用分区表，有其特点的根本原因：

- 对于Server层，分区表还是一个表
- 对于存储引擎层，分区表会是多张表